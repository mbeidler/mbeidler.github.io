<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="PH6uRiJc6RVau66VlhKy7gNm__ocbH910rwtWPls9DA">
    <title>Typechecked</title>
    <link rel="shortcut icon" href="./favicon.ico">
    <link rel="stylesheet" href="./site.css" />
  </head>
  <body>
    <div class="navbar navbar-inverse">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./">&lambda;</a>
      </div>
      <div class="navbar-collapse collapse navbar-responsive-collapse">
        <ul class="nav navbar-nav">
          <li>
            <a href="./about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
      
    <div class="container">
  <div class="panel panel-primary">
    <div class="panel-heading">
      <h3 class="panel-title"><a href="./posts/2014-10-23-bank-ocr-kata-2.html">The Bank OCR Kata in Haskell - Part 2</a></h3>
    </div>
    <div class="panel-body">
      
        <div style="font-weight: bold;">October 23, 2014</div>
      

      
        <div style="padding-top: 10px;">
          <span class="badge tag"><a href="./tags/Haskell.html">Haskell</a></span><span class="badge tag"><a href="./tags/Kata.html">Kata</a></span>
        </div>
        <br />
      

      <p>In <a href="http://www.typechecked.com/posts/2014-10-22-bank-ocr-kata-1.html">Part 1</a>, we implemented <strong>User Story 1</strong> from the <a href="http://codingdojo.org/cgi-bin/index.pl?KataBankOCR">Bank OCR Kata</a>. <strong>User Story 2</strong> specifies a simple checksum calculation to validate account numbers.</p>
<p><em>Starting Point</em></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mbeidler/BankOCR.git
<span class="kw">git</span> checkout -f part-1</code></pre></div>
<h3 id="user-story-2">User Story 2</h3>
<hr />
<p>To start, we will add a test to our spec:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bankOCRSpec <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span>
  describe <span class="st">&quot;When parsing human readable account numbers&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    <span class="fu">...</span>
    it <span class="st">&quot;should validate the checksum&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      isValid <span class="dv">711111111</span> <span class="ot">`shouldBe`</span> <span class="dt">True</span>
      isValid <span class="dv">111111117</span> <span class="ot">`shouldBe`</span> <span class="dt">False</span></code></pre></div>
<p><em>The Calculation</em></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">account number:  <span class="dv">3</span>  <span class="dv">4</span>  <span class="dv">5</span>  <span class="dv">8</span>  <span class="dv">8</span>  <span class="dv">2</span>  <span class="dv">8</span>  <span class="dv">6</span>  <span class="dv">5</span>
position names:  d9 d8 d7 d6 d5 d4 d3 d2 d1

checksum calculation:
(d1<span class="dv">+2</span><span class="op">*</span>d2<span class="dv">+3</span><span class="op">*</span>d3 <span class="op">+</span>..<span class="op">+</span><span class="dv">9</span><span class="op">*</span>d9) mod <span class="dv">11</span> <span class="op">=</span> <span class="dv">0</span></code></pre></div>
<p>We can <code class="sourceCode haskell">zip</code> the list of digit positions 1-9 with the digits in those positions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>] (reverse <span class="fu">.</span> show <span class="fu">$</span> n)<span class="ot"> ::</span> [(<span class="dt">Int</span>, <span class="dt">Char</span>)]</code></pre></div>
<p>Sum their products and check whether it is divisible by 11.</p>
<p>The computation can be expressed very succintly using a list comprehension.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isValid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isValid n <span class="fu">=</span> num <span class="ot">`mod`</span> <span class="dv">11</span> <span class="fu">==</span> <span class="dv">0</span>
  <span class="kw">where</span> 
    num <span class="fu">=</span> sum [ i <span class="fu">*</span> (digitToInt d) <span class="fu">|</span> (i,d) <span class="ot">&lt;-</span> zip [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>] (reverse <span class="fu">.</span> show <span class="fu">$</span> n) ]</code></pre></div>
<p><em>Note</em>: <code class="sourceCode haskell">digitToInt</code> is imported from <code class="sourceCode haskell"><span class="dt">Data.Char</span></code>.</p>
<p>Let’s run our tests.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">*BankOCR&gt;</span> :reload
[<span class="kw">1</span> of 1] Compiling BankOCR          ( BankOCR.hs, interpreted )
<span class="kw">Ok</span>, modules loaded: BankOCR.
<span class="kw">*BankOCR&gt;</span> bankOCRSpec

<span class="kw">When</span> parsing human readable account numbers
  <span class="kw">-</span> should parse 000000000
  <span class="kw">-</span> should parse 111111111
  <span class="kw">-</span> should parse 123456789
  <span class="kw">-</span> should validate the checksum

<span class="kw">Finished</span> in 0.0007 seconds
<span class="kw">4</span> examples, 0 failures
<span class="kw">*BankOCR&gt;</span> </code></pre></div>
<p><strong>Done!</strong></p>
<p><em>Source</em></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mbeidler/BankOCR.git
<span class="kw">git</span> checkout -f part-2</code></pre></div>
    </div>
  </div>
</div>


    <div class="container">
  <div class="panel panel-primary">
    <div class="panel-heading">
      <h3 class="panel-title"><a href="./posts/2014-10-22-bank-ocr-kata-1.html">The Bank OCR Kata in Haskell - Part 1</a></h3>
    </div>
    <div class="panel-body">
      
        <div style="font-weight: bold;">October 22, 2014</div>
      

      
        <div style="padding-top: 10px;">
          <span class="badge tag"><a href="./tags/Haskell.html">Haskell</a></span><span class="badge tag"><a href="./tags/Kata.html">Kata</a></span>
        </div>
        <br />
      

      <p>If you’ve never experimented with <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>, spare not a moment more! Install the <a href="http://www.haskell.org/platform/">Haskell Platform</a> on your preferred OS. <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good!</a> and <a href="http://book.realworldhaskell.org/">Real World Haskell</a> are excellent resources and as Haskell is quite a bit different from traditional languages, this <a href="http://stackoverflow.com/questions/1012573/getting-started-with-haskell#1016986">Stack Overflow answer</a> provides useful guidance on study strategies.</p>
<p>In this series of posts, we’re going to solve the <a href="http://codingdojo.org/cgi-bin/index.pl?KataBankOCR">Bank OCR Kata</a> with Haskell.</p>
<h3 id="setting-up-a-working-environment">Setting up a working environment</h3>
<hr />
<p>Create a working directory. We will sandbox our Haskell libraries here instead of installing them into <a href="http://www.haskell.org/cabal/">Cabal’s</a> global package database.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mkdir</span> BankOCR
<span class="kw">cd</span> BankOCR</code></pre></div>
<p>I recommend initializing an empty git repository to save your work at various points.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> init
<span class="kw">echo</span> <span class="st">&quot;.cabal-sandbox&quot;</span> <span class="kw">&gt;&gt;</span> .gitignore
<span class="kw">echo</span> <span class="st">&quot;cabal.sandbox.config&quot;</span> <span class="kw">&gt;&gt;</span> .gitignore
<span class="kw">echo</span> <span class="st">&quot;dist&quot;</span> <span class="kw">&gt;&gt;</span> .gitignore</code></pre></div>
<p>For the following command, select all defaults, with package build option set to <strong>Library</strong>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> init
<span class="kw">cabal</span> sandbox init</code></pre></div>
<p>Let’s create our source file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">echo</span> <span class="st">&quot;module BankOCR where&quot;</span> <span class="kw">&gt;&gt;</span> BankOCR.hs</code></pre></div>
<p>You will now see a <strong>BankOCR.cabal</strong> file. We’re going to use <a href="https://hspec.github.io/">Hspec</a> to write our test cases, so we’ll need to add that dependency to our cabal file.</p>
<p>Open <strong>BankOCR.cabal</strong> in a text editor, add <strong>hspec</strong> to the build-depends and set our library to use our newly created source file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">...</span>
<span class="kw">library</span>:
  <span class="kw">exposed-module</span>: BankOCR
  <span class="kw">...</span>
  <span class="kw">build-depends</span>: base <span class="kw">&gt;</span>=4.7 <span class="kw">&amp;&amp;</span> <span class="kw">&lt;4.8</span>, hspec
<span class="kw">...</span></code></pre></div>
<p>Now, let’s install our dependencies and open a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> with all the dependencies loaded.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> install --dependencies-only
<span class="kw">cabal</span> repl</code></pre></div>
<p>You should see something like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">...</span>
<span class="kw">Loading</span> package hspec-1.11.4 ... linking ... done.
[<span class="kw">1</span> of 1] Compiling BankOCR          ( BankOCR.hs, interpreted )
<span class="kw">Ok</span>, modules loaded: BankOCR.
<span class="kw">*BankOCR&gt;</span> </code></pre></div>
<p>Now, we can modify our BankOCR.hs file, enter <code class="sourceCode bash">:<span class="kw">reload</span></code> at the interactive prompt to reload our module and test out our changes.</p>
<h3 id="implementing-user-story-1">Implementing User Story 1</h3>
<hr />
<p>As we are using hspec and <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a>, we’ll write a simple spec for user story 1.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">BankOCR</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Test.Hspec</span>

bankOCRSpec <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span>
  describe <span class="st">&quot;When parsing human readable account numbers&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;should parse 000000000&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      parse zeros <span class="ot">`shouldBe`</span> <span class="dv">0</span>
    it <span class="st">&quot;should parse 111111111&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      parse ones <span class="ot">`shouldBe`</span> <span class="dv">111111111</span>
    it <span class="st">&quot;should parse 123456789&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      parse oneToNine <span class="ot">`shouldBe`</span> <span class="dv">123456789</span>

zeros <span class="fu">=</span> unlines
  [ <span class="st">&quot; _  _  _  _  _  _  _  _  _ &quot;</span>
  , <span class="st">&quot;| || || || || || || || || |&quot;</span>
  , <span class="st">&quot;|_||_||_||_||_||_||_||_||_|&quot;</span>
  , <span class="st">&quot;                           &quot;</span> ]

ones <span class="fu">=</span> unlines
  [ <span class="st">&quot;                           &quot;</span>
  , <span class="st">&quot;  |  |  |  |  |  |  |  |  |&quot;</span>
  , <span class="st">&quot;  |  |  |  |  |  |  |  |  |&quot;</span>
  , <span class="st">&quot;                           &quot;</span> ]

oneToNine <span class="fu">=</span> unlines
  [ <span class="st">&quot;    _  _     _     _  _  _ &quot;</span>
  , <span class="st">&quot;  | _| _||_||_ |_   ||_||_|&quot;</span>
  , <span class="st">&quot;  ||_  _|  | _||_|  ||_| _|&quot;</span>
  , <span class="st">&quot;                           &quot;</span> ]</code></pre></div>
<p>We will also stub out our parser to return a <a href="https://en.wikipedia.org/wiki/Bottom_type">bottom</a> type so that it compiles and we can run our tests.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
parse <span class="fu">=</span> undefined</code></pre></div>
<p>Now, if we enter <code class="sourceCode bash">:<span class="kw">reload</span></code> and evaluate <strong>bankOCRSpec</strong> in the interpreter, our tests will fail.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">*BankOCR&gt;</span> bankOCRSpec

<span class="kw">When</span> parsing human readable account numbers
  <span class="kw">-</span> should parse 000000000 FAILED [1]
  <span class="kw">-</span> should parse 111111111 FAILED [2]
  <span class="kw">-</span> should parse 123456789 FAILED [3]
<span class="kw">...</span></code></pre></div>
<p>We can start by using Haskell’s pattern matching to write a function that maps a 9-character string to the integer it represents.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">p' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
p' <span class="st">&quot; _ | ||_|&quot;</span> <span class="fu">=</span> <span class="dv">0</span>
p' <span class="st">&quot;     |  |&quot;</span> <span class="fu">=</span> <span class="dv">1</span>
p' <span class="st">&quot; _  _||_ &quot;</span> <span class="fu">=</span> <span class="dv">2</span>
p' <span class="st">&quot; _  _| _|&quot;</span> <span class="fu">=</span> <span class="dv">3</span>
p' <span class="st">&quot;   |_|  |&quot;</span> <span class="fu">=</span> <span class="dv">4</span>
p' <span class="st">&quot; _ |_  _|&quot;</span> <span class="fu">=</span> <span class="dv">5</span>
p' <span class="st">&quot;   |_ |_|&quot;</span> <span class="fu">=</span> <span class="dv">6</span>
p' <span class="st">&quot; _   |  |&quot;</span> <span class="fu">=</span> <span class="dv">7</span>
p' <span class="st">&quot; _ |_||_|&quot;</span> <span class="fu">=</span> <span class="dv">8</span>
p' <span class="st">&quot; _ |_| _|&quot;</span> <span class="fu">=</span> <span class="dv">9</span>
p' _           <span class="fu">=</span> error <span class="st">&quot;unknown symbol&quot;</span></code></pre></div>
<p>Now, to read account numbers we simply need to apply the necessary transformations to the input string to get a list of strings that <code class="sourceCode haskell">p'</code> can <strong>fold</strong> over to <strong>accumulate</strong> the resulting number.</p>
<p>So we start with an input <code class="sourceCode haskell"><span class="dt">String</span></code> and:</p>
<ol style="list-style-type: decimal">
<li>Split on newline characters using Haskell’s <code class="sourceCode haskell">lines</code> function. <code class="sourceCode haskell"><span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></li>
<li>Use the <code class="sourceCode haskell">init</code> function to discard the last line of whitespace. <code class="sourceCode haskell">[<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></li>
<li><p>We further parition all the strings into 3-character triples. <code class="sourceCode haskell">[<span class="dt">String</span>] <span class="ot">-&gt;</span> [[<span class="dt">String</span>]]</code> To do so, we introduce the following function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">triples ::</span> [a] <span class="ot">-&gt;</span> [[a]]
triples (a<span class="fu">:</span>b<span class="fu">:</span>c<span class="fu">:</span>xs) <span class="fu">=</span> [a,b,c] <span class="fu">:</span> triples xs
triples _          <span class="fu">=</span> []</code></pre></div>
<p>Now, if we test out our steps so far in the interpreter, we get a list of lines, where the first line is a list of the top cell rows, and so on.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">*BankOCR&gt;</span> map triples . init . lines $ ones
[[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>],[<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>]]</code></pre></div></li>
<li><p>We can see that to continue, we need a way to combine the first element of the first line’s list with the first element of the second line’s list, etc. Conveniently, Haskell already has a <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:transpose">transpose</a> function that performs exactly that operation. <code class="sourceCode haskell">[[<span class="dt">String</span>]] <span class="ot">-&gt;</span> [[<span class="dt">String</span>]]</code></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">*BankOCR&gt;</span> :m + Data.List
<span class="kw">*BankOCR&gt;</span> transpose it
[[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>]]</code></pre></div></li>
<li><p>All that remains is to collapse the 3 rows of 3 characters into one 9-character string using <code class="sourceCode haskell">map concat</code>. <code class="sourceCode haskell">[[<span class="dt">String</span>]] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></p></li>
</ol>
<p>So, now we have a transformation that takes the input string and yields a list of digit strings that <code class="sourceCode haskell">p'</code> can parse and it’s straight-forward to write a parse function using a left fold.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
parse <span class="fu">=</span> foldl f <span class="dv">0</span> <span class="fu">.</span> prep
  <span class="kw">where</span>
    prep <span class="fu">=</span> map concat <span class="fu">.</span> transpose <span class="fu">.</span> map triples <span class="fu">.</span> init <span class="fu">.</span> lines
    f n digit <span class="fu">=</span> <span class="kw">let</span> r' <span class="fu">=</span> p' digit <span class="kw">in</span> r' <span class="fu">+</span> <span class="dv">10</span> <span class="fu">*</span> n</code></pre></div>
<p>Add the necessary import at the top of the file.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (transpose)
<span class="kw">import </span><span class="dt">Test.Hspec</span></code></pre></div>
<p>Now, if we reload and run our tests in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">*BankOCR&gt;</span> bankOCRSpec

<span class="kw">When</span> parsing human readable account numbers
  <span class="kw">-</span> should parse 000000000
  <span class="kw">-</span> should parse 111111111
  <span class="kw">-</span> should parse 123456789

<span class="kw">Finished</span> in 0.0004 seconds
<span class="kw">3</span> examples, 0 failures</code></pre></div>
<h3 id="conclusion">Conclusion</h3>
<hr />
<p>It is quite satisfying that with pattern matching, function composition and higher-order functions, this Haskell implementation is only 19 lines long!</p>
<p><br /></p>
<p><em>Source</em></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mbeidler/BankOCR.git
<span class="kw">git</span> checkout -f post-1</code></pre></div>
    </div>
  </div>
</div>



    <footer class="container">
      <div class="panel panel-default">
        <div class="panel-body">
          Site proudly generated by
          <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          <div class="pull-right">
            Source available on <a href="http://www.github.com/mbeidler/mbeidler.github.io">GitHub</a>
          </div>
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="./js/jquery-2.1.1.min.js"></script>
    <script type="text/javascript" src="./js/bootstrap.min.js"></script>
  </body>
</html>
