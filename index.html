<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="PH6uRiJc6RVau66VlhKy7gNm__ocbH910rwtWPls9DA">
    <title>Typechecked</title>
    <link rel="shortcut icon" href="./favicon.ico">
    <link rel="stylesheet" href="./site.css" />
  </head>
  <body>
    <div class="navbar navbar-inverse">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./">&lambda;</a>
      </div>
      <div class="navbar-collapse collapse navbar-responsive-collapse">
        <ul class="nav navbar-nav">
          <li>
            <a href="./about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
      
    <div class="container">
  <div class="panel panel-primary">
    <div class="panel-heading">
      <h3 class="panel-title"><a href="./posts/2016-01-01-bank-ocr-kata.html">The Bank OCR Kata in Haskell</a></h3>
    </div>
    <div class="panel-body">
      
        <div style="font-weight: bold;">January  1, 2016</div>
      

      
        <div style="padding-top: 10px;">
          <span class="badge tag"><a href="./tags/Haskell.html">Haskell</a></span><span class="badge tag"><a href="./tags/Kata.html">Kata</a></span>
        </div>
        <br />
      

      <p>In this post, we’re going use Haskell to solve the <a href="http://codingdojo.org/cgi-bin/index.pl?KataBankOCR">Bank OCR Kata</a>.</p>
<p>If you’d like to follow along with the code you can clone the following repository:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/mbeidler/kata-bank-ocr</code></pre></div>
<h3 id="summary">Summary</h3>
<hr />
<p>To complete this kata, we must:</p>
<ol style="list-style-type: decimal">
<li>Parse human readable bank account strings.</li>
<li>Validate the result.</li>
<li>Print results, reporting illegible and invalid accounts as such.</li>
<li>For misses and invalid accounts, work backwards to produce a set of valid candidates that could’ve produced the error.</li>
</ol>
<h3 id="types">Types</h3>
<hr />
<p>In Haskell, the dogma is that <em>if it compiles, it works</em>.</p>
<p>One of the ways we labor to achieve this is to:</p>
<blockquote>
<p>Make illegal states unrepresentable. -Yaron Minsky</p>
</blockquote>
<p>So, to start, we can see that this Kata gives us a clear specification of some of the types we will be working with.</p>
<p>We will follow the common practice of creating a <code class="sourceCode haskell"><span class="dt">Types</span></code> module so that we can hide the internal implementations and export only <a href="https://wiki.haskell.org/Smart_constructors">smart constructors</a>.</p>
<p>To represent digits we will use a simple <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper around <code class="sourceCode haskell"><span class="dt">Int</span></code>. This gives us strong type safety with no runtime overhead. We will simply display it as we would an <code class="sourceCode haskell"><span class="dt">Int</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="fu">=</span> <span class="dt">Digit</span> {<span class="ot"> unDigit ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Digit</span> <span class="kw">where</span>
    show <span class="fu">=</span> show <span class="fu">.</span> unDigit</code></pre></div>
<p>Note: we do not export <code class="sourceCode haskell">unDigit</code>.</p>
<p>The only way to create values of <code class="sourceCode haskell"><span class="dt">Digit</span></code> is to use the smart constructors we provide:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zero, one, two, three, four, five, six, seven, eight,<span class="ot"> nine ::</span> <span class="dt">Digit</span>
zero  <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">0</span>
one   <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">1</span>
two   <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">2</span>
three <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">3</span>
four  <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">4</span>
five  <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">5</span>
six   <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">6</span>
seven <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">7</span>
eight <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">8</span>
nine  <span class="fu">=</span> <span class="dt">Digit</span> <span class="dv">9</span></code></pre></div>
<p>We will use a similar technique for <code class="sourceCode haskell"><span class="dt">Account</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Account</span> <span class="fu">=</span> <span class="dt">Account</span> {<span class="ot"> account ::</span> [<span class="dt">Digit</span>] } <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Account</span> <span class="kw">where</span>
    show <span class="fu">=</span> concatMap show <span class="fu">.</span> account

<span class="ot">fromList ::</span> [<span class="dt">Digit</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Account</span>
fromList ds <span class="fu">|</span> length ds <span class="fu">==</span> <span class="dv">9</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Account</span> ds
            <span class="fu">|</span> otherwise      <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>We only export <code class="sourceCode haskell">fromList</code>, so it is impossible to create an <code class="sourceCode haskell"><span class="dt">Account</span></code> that doesn’t have exactly 9 digits.</p>
<p><strong>User Story 2</strong> specifies a simple checksum calculation for account verification (implemented by the <code class="sourceCode haskell">isValid</code> function). We will create a separate type for <code class="sourceCode haskell"><span class="dt">Verified</span></code> accounts and use the validation in our smart constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Verified</span> <span class="fu">=</span> <span class="dt">Verified</span> {<span class="ot"> verified ::</span> <span class="dt">Account</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Verified</span> <span class="kw">where</span>
    show <span class="fu">=</span> show <span class="fu">.</span> verified

<span class="ot">verify ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Verified</span>
verify a <span class="fu">|</span> isValid a <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Verified</span> a
         <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="ot">isValid ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isValid (<span class="dt">Account</span> ds) <span class="fu">=</span>
    (sum <span class="fu">$</span> zipWith (<span class="fu">*</span>) [<span class="dv">9</span>,<span class="dv">8</span><span class="fu">..</span><span class="dv">1</span>] (map unDigit ds)) <span class="ot">`mod`</span> <span class="dv">11</span> <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>Because we used <code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></code> to derive an <code class="sourceCode haskell"><span class="dt">Enum</span></code> instance for <code class="sourceCode haskell"><span class="dt">Digit</span></code>, we can use our smart constructors in range notation. We’ll use the <code class="sourceCode haskell"><span class="dt">Maybe</span></code> monad to attempt to create a verified account.</p>
<p>We can test this out in our <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fromList [one<span class="fu">..</span>nine] <span class="fu">&gt;&gt;=</span> verify
<span class="dt">Just</span> <span class="dv">123456789</span>
λ<span class="fu">&gt;</span> fromList (replicate <span class="dv">9</span> one) <span class="fu">&gt;&gt;=</span> verify
<span class="dt">Nothing</span></code></pre></div>
<p>Success! That does it for our <code class="sourceCode haskell"><span class="dt">Types</span></code> module.</p>
<h3 id="reading-accounts">Reading Accounts</h3>
<hr />
<p>Let’s create a new <code class="sourceCode haskell"><span class="dt">Reader</span></code> module to do the heavy lifting.</p>
<p>We need a simple association list from a human readable 9-character <code class="sourceCode haskell"><span class="dt">String</span></code> to the <code class="sourceCode haskell"><span class="dt">Digit</span></code> it represents.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">digitMap ::</span> [(<span class="dt">String</span>, <span class="dt">Digit</span>)]
digitMap <span class="fu">=</span>
  [ (<span class="st">&quot; _ | ||_|&quot;</span>, zero)
  , (<span class="st">&quot;     |  |&quot;</span>, one)
  , (<span class="st">&quot; _  _||_ &quot;</span>, two)
  , (<span class="st">&quot; _  _| _|&quot;</span>, three)
  , (<span class="st">&quot;   |_|  |&quot;</span>, four)
  , (<span class="st">&quot; _ |_  _|&quot;</span>, five)
  , (<span class="st">&quot; _ |_ |_|&quot;</span>, six)
  , (<span class="st">&quot; _   |  |&quot;</span>, seven)
  , (<span class="st">&quot; _ |_||_|&quot;</span>, eight)
  , (<span class="st">&quot; _ |_| _|&quot;</span>, nine) ]</code></pre></div>
<p>Reading a single digit will either fail, in which case we want to return alternatives “one character miss” away, or the digit we read. We can use Haskell’s <code class="sourceCode haskell"><span class="dt">Either</span></code> type for this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DigitR</span> <span class="fu">=</span> <span class="dt">Either</span> [<span class="dt">Digit</span>] <span class="dt">Digit</span></code></pre></div>
<p>We’ll need the following functions for finding digits one character away:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">near ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Digit</span>]
near str <span class="fu">=</span> [ d <span class="fu">|</span> (s,d) <span class="ot">&lt;-</span> digitMap, diffSum str s <span class="fu">==</span> <span class="dv">1</span>]

<span class="ot">diffSum ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
diffSum xs <span class="fu">=</span> length <span class="fu">.</span> filter not <span class="fu">.</span> zipWith (<span class="fu">==</span>) xs</code></pre></div>
<p>Now we can write a simple function to read a digit from a digit string. If the lookup fails it will enumerate the <em>1-near</em> neighbors and store them in the <code class="sourceCode haskell"><span class="dt">Left</span></code> constructor. Otherwise, it will simply return the <code class="sourceCode haskell"><span class="dt">Digit</span></code> on the <code class="sourceCode haskell"><span class="dt">Right</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readDigit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DigitR</span>
readDigit s <span class="fu">=</span> maybe (<span class="dt">Left</span> <span class="fu">$</span> near s) <span class="dt">Right</span> <span class="fu">$</span> lookup s digitMap</code></pre></div>
<p>We can test out our implementation in our interpreter:</p>
<ul>
<li><p>Reading the keys in the association list should all succeed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> and [ (readDigit s) <span class="fu">==</span> (<span class="dt">Right</span> d) <span class="fu">|</span> (s,d) <span class="ot">&lt;-</span> digitMap ]
<span class="dt">True</span></code></pre></div></li>
<li><p>A one character miss should return a non-empty list on the <code class="sourceCode haskell"><span class="dt">Left</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> readDigit ((take <span class="dv">8</span> (fst (digitMap <span class="fu">!!</span> <span class="dv">3</span>))) <span class="fu">++</span> <span class="st">&quot; &quot;</span>)
<span class="dt">Left</span> [<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div></li>
</ul>
<p>To implement <strong>User Story 4</strong>, we need to be able to expand our search space when we encounter an illegible or invalid account string. We’ll use this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Success</span> (<span class="dt">Either</span> ([<span class="dt">DigitR</span>], [<span class="dt">Verified</span>]) <span class="dt">Verified</span>)
            <span class="fu">|</span> <span class="dt">Miss</span> [<span class="dt">DigitR</span>] [<span class="dt">Verified</span>]</code></pre></div>
<p>to represent the end result. The <code class="sourceCode haskell"><span class="dt">Success</span></code> constructor represents the case where all digits were legible. The successful read is either valid (the <code class="sourceCode haskell"><span class="dt">Right</span></code> side) or invalid, in which case we store the reads and the list of verified accounts one character miss away. Note: to improve readability and add a bit more type safety, the <code class="sourceCode haskell">[<span class="dt">DigitR</span>]</code> and <code class="sourceCode haskell">[<span class="dt">Verified</span>]</code> fields could be collapsed into a new type called <code class="sourceCode haskell"><span class="dt">Candidates</span></code>.</p>
<p>So, assuming we have a list of digit strings (transforming the input data to achieve this will be covered at the end), we can run our read function to produce a <code class="sourceCode haskell">[<span class="dt">DigitR</span>]</code>.</p>
<p>Instead of enumerating near digits every time, it is better to store their <em>1-near</em> neighbors in a <code class="sourceCode haskell"><span class="dt">Map</span></code>. We’ll first enumerate the relationships using our <code class="sourceCode haskell">digitMap</code> in GHCi:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>m <span class="fu">+</span> <span class="dt">Control.Arrow</span>
λ<span class="fu">&gt;</span> map (near <span class="fu">***</span> id) digitMap
[([<span class="dv">8</span>],<span class="dv">0</span>),([<span class="dv">7</span>],<span class="dv">1</span>),([],<span class="dv">2</span>),([<span class="dv">9</span>],<span class="dv">3</span>),([],<span class="dv">4</span>),([<span class="dv">6</span>,<span class="dv">9</span>],<span class="dv">5</span>),([<span class="dv">5</span>,<span class="dv">8</span>],<span class="dv">6</span>),([<span class="dv">1</span>],<span class="dv">7</span>),([<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">9</span>],<span class="dv">8</span>),([<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>],<span class="dv">9</span>)]</code></pre></div>
<p>Then we can build our map.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">kin ::</span> <span class="dt">Map</span> <span class="dt">Digit</span> [<span class="dt">Digit</span>]
kin <span class="fu">=</span> M.fromList <span class="fu">$</span>
  [ (zero,  [zero, eight])
  , (one,   [one, seven])
  , (two,   [two])
  , (three, [three, nine])
  , (four,  [four])
  , (five,  [five, six, nine])
  , (six,   [five, six, eight])
  , (seven, [one, seven])
  , (eight, [zero, six, eight, nine])
  , (nine,  [three, five, eight, nine])
  ]</code></pre></div>
<p>Note: we include each key in the list of neighbors as well as it simplifies the search algorithm we will use.</p>
<p>To expand our search space and produce the list of valid candidates, we:</p>
<ol style="list-style-type: decimal">
<li>Collect the <code class="sourceCode haskell"><span class="dt">Left</span></code> and <code class="sourceCode haskell"><span class="dt">Right</span></code> digits in our <code class="sourceCode haskell">[<span class="dt">DigitR</span>]</code>.</li>
<li><code class="sourceCode haskell">sequence</code> them using the list monad.</li>
<li>Map our smart constructors over them using the <code class="sourceCode haskell"><span class="dt">Maybe</span></code> monad.</li>
<li>Use <code class="sourceCode haskell">catMaybes</code> to collect the <code class="sourceCode haskell"><span class="dt">Just</span> <span class="dt">Verified</span></code> accounts.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">expand ::</span> [[<span class="dt">Digit</span>]] <span class="ot">-&gt;</span> [<span class="dt">Verified</span>]
expand <span class="fu">=</span>  catMaybes <span class="fu">.</span> map ((<span class="fu">=&lt;&lt;</span>) verify <span class="fu">.</span> fromList) <span class="fu">.</span> sequence

<span class="ot">mapEither ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> [c]
mapEither f g <span class="fu">=</span> map (either f g)

<span class="ot">collect ::</span> [<span class="dt">DigitR</span>] <span class="ot">-&gt;</span> [[<span class="dt">Digit</span>]]
collect <span class="fu">=</span> mapEither id pure</code></pre></div>
<p>When we have an account string with no illegible digits, the candidate selection process is a bit different. In this case, we need to expand our space by replacing each digit (one at a time) with the list of alternatives from our <code class="sourceCode haskell">kin</code> <code class="sourceCode haskell"><span class="dt">Map</span></code>. To do so succinctly, we will use a few operators from the <code class="sourceCode haskell"><span class="dt">Lens</span></code> package that make working with <code class="sourceCode haskell"><span class="dt">Map</span></code>s much cleaner. The core of our solution is in the following <code class="sourceCode haskell">run</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">run ::</span> [<span class="dt">DigitR</span>] <span class="ot">-&gt;</span> <span class="dt">Result</span>
run reads
     <span class="fu">|</span> all isRight reads <span class="fu">=</span>
         <span class="dt">Success</span> <span class="fu">$</span> <span class="kw">case</span> accnt <span class="fu">&gt;&gt;=</span> verify <span class="kw">of</span>
           <span class="dt">Just</span> v  <span class="ot">-&gt;</span> <span class="dt">Right</span> v
           <span class="dt">Nothing</span> <span class="ot">-&gt;</span>
               <span class="dt">Left</span> (reads, concatMap expand <span class="fu">$</span> map f [<span class="dv">0</span><span class="fu">..</span><span class="dv">8</span>])
     <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Miss</span> reads <span class="fu">$</span> expand space
  <span class="kw">where</span>
    space <span class="fu">=</span> collect reads
    ds <span class="fu">=</span> rights reads
    accnt <span class="fu">=</span> fromList ds
    f i <span class="fu">=</span> space <span class="fu">&amp;</span> ix i <span class="fu">.~</span> (fromJust <span class="fu">$</span> kin <span class="fu">^.</span>at (ds <span class="fu">!!</span> i))</code></pre></div>
<p>We’ll write a few functions for rendering our values to strings according to the Kata’s specification.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Result</span> <span class="kw">where</span>
    show (<span class="dt">Success</span> (<span class="dt">Right</span> v))       <span class="fu">=</span> show v
    show (<span class="dt">Success</span> (<span class="dt">Left</span> (rs, vs))) <span class="fu">=</span> showRes rs vs
    show (<span class="dt">Miss</span> rs vs)              <span class="fu">=</span> showRes rs vs

<span class="ot">showRes ::</span> [<span class="dt">DigitR</span>] <span class="ot">-&gt;</span> [<span class="dt">Verified</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
showRes rs []  <span class="fu">=</span> report rs <span class="fu">++</span> <span class="st">&quot; ILL&quot;</span>
showRes _  [v] <span class="fu">=</span> show v
showRes rs vs  <span class="fu">=</span> concat [report rs, <span class="st">&quot; AMB &quot;</span>, show vs]

<span class="ot">report ::</span> [<span class="dt">DigitR</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
report <span class="fu">=</span> mapEither (const <span class="ch">'?'</span>) (head <span class="fu">.</span> show)</code></pre></div>
<p>And now we can verify some of the sample inputs on our <code class="sourceCode haskell">run</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> run (map <span class="dt">Right</span> (replicate <span class="dv">9</span> one))
<span class="dv">711111111</span>
λ<span class="fu">&gt;</span> run (map <span class="dt">Right</span> (replicate <span class="dv">9</span> seven))
<span class="dv">777777177</span>
λ<span class="fu">&gt;</span> run (map <span class="dt">Right</span> (replicate <span class="dv">9</span> eight))
<span class="dv">888888888</span> <span class="dt">AMB</span> [<span class="dv">888886888</span>,<span class="dv">888888988</span>,<span class="dv">888888880</span>]</code></pre></div>
<p>Finally, we need to take the account string input and transform it into a list of digits strings.</p>
<h4 id="paritioning-account-strings-into-a-list-of-digits">Paritioning Account Strings into a List of Digits</h4>
<hr />
<p>To read account numbers we simply need to apply the necessary transformations to the input string to get a list of strings that we can map over to produce a list of reads.</p>
<p>So we start with an input <code class="sourceCode haskell"><span class="dt">String</span></code> and:</p>
<ol style="list-style-type: decimal">
<li>Split on newline characters using Haskell’s <code class="sourceCode haskell">lines</code> function. <code class="sourceCode haskell"><span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></li>
<li>Use the <code class="sourceCode haskell">init</code> function to discard the last line of whitespace. <code class="sourceCode haskell">[<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></li>
<li><p>We further parition all the strings into 3-character triples. <code class="sourceCode haskell">[<span class="dt">String</span>] <span class="ot">-&gt;</span> [[<span class="dt">String</span>]]</code> To do so, we introduce the following function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">triples (a<span class="fu">:</span>b<span class="fu">:</span>c<span class="fu">:</span>xs) <span class="fu">=</span> [a,b,c] <span class="fu">:</span> triples xs
triples _          <span class="fu">=</span> []</code></pre></div>
<p>Now, if we test out our steps so far in the interpreter, we get a list of lines, where the first line is a list of the top cell rows, and so on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> map triples <span class="fu">.</span> init <span class="fu">.</span> lines <span class="fu">$</span> ones
[[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>,<span class="st">&quot;   &quot;</span>],[<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>]]</code></pre></div></li>
<li><p>We can see that to continue, we need a way to combine the first element of the first line’s list with the first element of the second line’s list, etc. Conveniently, Haskell already has a <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:transpose">transpose</a> function that performs exactly that operation. <code class="sourceCode haskell">[[<span class="dt">String</span>]] <span class="ot">-&gt;</span> [[<span class="dt">String</span>]]</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>m <span class="fu">+</span> <span class="dt">Data.List</span>
λ<span class="fu">&gt;</span> transpose it
[[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>],[<span class="st">&quot;   &quot;</span>,<span class="st">&quot;  |&quot;</span>,<span class="st">&quot;  |&quot;</span>]]</code></pre></div></li>
<li><p>All that remains is to collapse the 3 rows of 3 characters into one 9-character string using <code class="sourceCode haskell">map concat</code>. <code class="sourceCode haskell">[[<span class="dt">String</span>]] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></p></li>
</ol>
<p>So, now we have a transformation that takes the input string and yields a list of digit strings that we can parse.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prepare ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
prepare <span class="fu">=</span> map concat <span class="fu">.</span> transpose <span class="fu">.</span> map triples <span class="fu">.</span> init <span class="fu">.</span> lines
  <span class="kw">where</span>
    triples (a<span class="fu">:</span>b<span class="fu">:</span>c<span class="fu">:</span>xs) <span class="fu">=</span> [a,b,c] <span class="fu">:</span> triples xs
    triples _          <span class="fu">=</span> []</code></pre></div>
<p>And we can use <code class="sourceCode haskell">prepare</code> to create a <code class="sourceCode haskell">readAccount</code> function, which together with the <code class="sourceCode haskell"><span class="dt">Result</span></code> type are our only exports.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readAccount ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span>
readAccount <span class="fu">=</span> run <span class="fu">.</span> readDigits

<span class="ot">readDigits ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">DigitR</span>]
readDigits <span class="fu">=</span> map readDigit <span class="fu">.</span> prepare</code></pre></div>
<h3 id="main">Main</h3>
<hr />
<p>Now, we just tie everything together with a simple command line application. In our <strong>Main.hs</strong> file we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Reader</span> (readAccount, <span class="dt">Result</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> getContents <span class="fu">&gt;&gt;=</span> mapM_ (print <span class="fu">.</span> readAccount) <span class="fu">.</span> quads <span class="fu">.</span> lines
  <span class="kw">where</span>
    quads (a<span class="fu">:</span>b<span class="fu">:</span>c<span class="fu">:</span>d<span class="fu">:</span>xs) <span class="fu">=</span> unlines [a,b,c,d] <span class="fu">:</span> quads xs
    quads _            <span class="fu">=</span> []</code></pre></div>
<p>In a real application, I’d put this into a test suite, but that feels like going overboard in this case. Instead, I just downloaded the inputs from the Kata into a <strong>test/accounts.txt</strong> file, and ran the app over them to verify the results.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> test/accounts.txt <span class="kw">|</span> <span class="kw">cabal</span> run
<span class="kw">Preprocessing</span> executable <span class="st">'kata-bank-ocr'</span> for kata-bank-ocr-0.0.0.1...
<span class="kw">Running</span> kata-bank-ocr...
<span class="kw">711111111</span>
<span class="kw">777777177</span>
<span class="kw">200800000</span>
<span class="kw">333393333</span>
<span class="kw">888888888</span> AMB [888886888,888888988,888888880]
<span class="kw">555555555</span> AMB [559555555,555655555]
<span class="kw">666666666</span> AMB [686666666,666566666]
<span class="kw">999999999</span> AMB [899999999,993999999,999959999]
<span class="kw">490067715</span> AMB [490867715,490067115,490067719]
<span class="kw">123456789</span>
<span class="kw">000000051</span>
<span class="kw">490867715</span></code></pre></div>
<p>That’s all for now! I hope you enjoyed this post. Happy Hacking!</p>
    </div>
  </div>
</div>



    <footer class="container">
      <div class="panel panel-default">
        <div class="panel-body">
          Site proudly generated by
          <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          <div class="pull-right">
            Source available on <a href="http://www.github.com/mbeidler/mbeidler.github.io">GitHub</a>
          </div>
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="./js/jquery-2.1.1.min.js"></script>
    <script type="text/javascript" src="./js/bootstrap.min.js"></script>
  </body>
</html>
